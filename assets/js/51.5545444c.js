(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{256:function(e,t,r){"use strict";r.r(t);var a=r(28),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"常见问题集合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见问题集合"}},[e._v("#")]),e._v(" 常见问题集合")]),e._v(" "),r("blockquote",[r("p",[e._v("转自 https://juejin.im/post/59fa9257f265da43062a1b0e#heading-76\n我觉得大部分问题，咋们可以先百度！！")])]),e._v(" "),r("h2",{attrs:{id:"安装超时-install-timeout"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装超时-install-timeout"}},[e._v("#")]),e._v(" 安装超时(install timeout)")]),e._v(" "),r("h3",{attrs:{id:"解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[e._v("#")]),e._v(" 解决方案")]),e._v(" "),r("ul",[r("li",[e._v("cnpm : 国内对 npm 的镜像版本")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/*\ncnpm website: https://npm.taobao.org/\n*/\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n// cnpm 的大多命令跟 npm 的是一致的,比如安装,卸载这些\n\n")])])]),r("ul",[r("li",[e._v("yarn 和 npm 改源大法")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("使用 nrm 模块 : www.npmjs.com/package/nrm\nnpm config : npm config set registry https://registry.npm.taobao.org\nyarn config : yarn config set registry https://registry.npm.taobao.org\n")])])]),r("h2",{attrs:{id:"想学习-vue-要先学习脚手架的搭建么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#想学习-vue-要先学习脚手架的搭建么"}},[e._v("#")]),e._v(" 想学习 Vue,要先学习脚手架的搭建么")]),e._v(" "),r("p",[e._v("若是你想快速上手，用官方的脚手架即可(Vue-Cli 3) "),r("br"),e._v("\n因为不管是 webpack 还是 parcel，gulp，都是一些构建工作流的东东； "),r("br"),e._v("\n学习脚手架的搭建，更多的是要针对项目业务进行定制，调优； "),r("br"),e._v("\n一般入门级的无需太早考虑这方面的，只要专心学好 Vue 的使用姿势便可。")]),e._v(" "),r("h2",{attrs:{id:"安装一些需要编译的包-提示没有安装-python、build-失败等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装一些需要编译的包-提示没有安装-python、build-失败等"}},[e._v("#")]),e._v(" 安装一些需要编译的包:提示没有安装 python、build 失败等")]),e._v(" "),r("p",[e._v("因为一些 npm 的包安装需要编译的环境,mac 和 linux 都还好,"),r("br"),e._v("\n而 window 用户依赖 visual studio 的一些库和 python 2+,"),r("br"),e._v("\nwindows 的小伙伴都装上:"),r("br"),e._v(" "),r("a",{attrs:{href:"https://github.com/felixrieseberg/windows-build-tools",title:"windows-build-tools",target:"_blank"}},[e._v("windows-build-tools")]),r("br"),e._v(" "),r("a",{attrs:{href:"https://www.python.org/downloads/",title:"python 2.x",target:"_blank"}},[e._v("python 2.x")])]),e._v(" "),r("h2",{attrs:{id:"can-t-not-find-xxmodule-找不到某些依赖或者模块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#can-t-not-find-xxmodule-找不到某些依赖或者模块"}},[e._v("#")]),e._v(" can't not find 'xxModule' - 找不到某些依赖或者模块")]),e._v(" "),r("p",[e._v("这种情况一般报错信息可以看到是哪个包抛出的信息，一般卸载这个模块,安装重新安装下即可。")]),e._v(" "),r("h2",{attrs:{id:"data-functions-should-return-an-object"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#data-functions-should-return-an-object"}},[e._v("#")]),e._v(" data functions should return an object")]),e._v(" "),r("p",[e._v("这个问题是 Vue 实例内,单组件的 data 必须返回一个对象;如下")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export default {\n  name: 'page-router-view',\n      data () {\n      return {\n        tabs: [\n          {\n            title: '财务信息',\n            url: '/userinfo'\n          },\n          {\n            title: '帐号信息',\n            url: '/userinfo/base'\n          }\n        ]\n      }\n    }\n}\n")])])]),r("p",[r("strong",[e._v("为什么要 return 一个数据对象呢?")]),e._v("\n官方解释如下: data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。"),r("br"),e._v("\n如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！"),r("br"),e._v("\n简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题,")]),e._v(" "),r("h2",{attrs:{id:"我给组件内的原生控件添加事件不生效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我给组件内的原生控件添加事件不生效"}},[e._v("#")]),e._v(" 我给组件内的原生控件添加事件不生效!")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n\x3c!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--\x3e\n\n\x3c!--// 错误例子1--\x3e\n<el-input placeholder="请输入特定消费金额 " @mouseover="test()"></el-input>\n\n\n\x3c!--// 错误例子2--\x3e\n<router-link :to="item.menuUrl" @click="toggleName=\'\'">\n  <i :class="[\'fzicon\',item.menuIcon]"></i>\n  <span>{{item.menuName}}</span>\n</router-link>\n\n\n\x3c!--上面的两个例子都没法触发事件!--\x3e\n\x3c!--究其原因,少了一个修饰符 .native--\x3e\n<router-link :to="item.menuUrl" @click.native="toggleName=\'\'">\n  <i :class="[\'fzicon\',item.menuIcon]"></i>\n  <span>{{item.menuName}}</span>\n</router-link>\n\n\x3c!--明明官方文档有的,一堆人不愿意去看,,Fuck--\x3e\n\x3c!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--\x3e\n\n')])])]),r("h2",{attrs:{id:"provide-和-inject-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#provide-和-inject-是什么"}},[e._v("#")]),e._v(" provide 和 inject 是什么")]),e._v(" "),r("p",[e._v("Vue 在 2.2 的时候,也提供了该概念。类比 ng provider 和 react context;")]),e._v(" "),r("h2",{attrs:{id:"我用了-axios-为什么-ie-浏览器不识别-ie9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我用了-axios-为什么-ie-浏览器不识别-ie9"}},[e._v("#")]),e._v(" 我用了 axios , 为什么 IE 浏览器不识别(IE9+)")]),e._v(" "),r("p",[e._v("那是因为 IE 整个家族都不支持 promise, 解决方案:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('npm install es6-promise\n\n// 在 main.js 引入即可\n// ES6的polyfill\nrequire("es6-promise").polyfill();\n\n')])])]),r("h2",{attrs:{id:"我在函数内用了-this-xxx-为什么抛出-cannot-set-property-xxx-of-undefined"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我在函数内用了-this-xxx-为什么抛出-cannot-set-property-xxx-of-undefined"}},[e._v("#")]),e._v(" 我在函数内用了 this.xxx=,为什么抛出 Cannot set property 'xxx' of undefined;")]),e._v(" "),r("p",[e._v("这又是 this 的套路了,this 是和当前运行的上下文绑定的,"),r("br"),e._v("\n一般你在 axios 或者其他 promise , 或者 setInterval 这些默认都是指向最外层的全局钩子."),r("br"),e._v('\n简单点说:"最外层的上下文就是 window,vue 内则是 Vue 对象而不是实例!";'),r("br")]),e._v(" "),r("h3",{attrs:{id:"解决方案-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[e._v("#")]),e._v(" 解决方案")]),e._v(" "),r("p",[e._v("暂存法: 函数内先缓存 this , let that = this;(let 是 es6, es5 用 var)"),r("br"),e._v("\n箭头函数: 会强行关联当前运行区域为 this 的上下文;"),r("br"),e._v('\nthis 的知识, 读"<<你不知道的 JS 系列>>"最为合适了,里面讲的很清楚')]),e._v(" "),r("h2",{attrs:{id:"我看一些-vue-教程有这么些写法-是什么意思-click-prevent-v-demo-a-b"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我看一些-vue-教程有这么些写法-是什么意思-click-prevent-v-demo-a-b"}},[e._v("#")]),e._v(" 我看一些 Vue 教程有这么些写法,是什么意思@click.prevent,v-demo.a.b")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("@click.prevent")]),e._v(" : 事件+修饰符 , 作用就是点击但又阻止默认行为")]),e._v(" "),r("li",[r("strong",[e._v("v-demo.a.b")]),e._v(": 自定义指令+修饰符. 具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能\n比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等"),r("br"),e._v(" "),r("strong",[e._v("传送门:")]),r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6",title:"事件修饰符",target:"_blank"}},[e._v("事件修饰符")]),e._v("\n可以自定义修饰符么?也是可以的,"),r("br"),e._v("\n可以通过全局 "),r("strong",[e._v("config.keyCodes")]),e._v(" 对象自定义键值修饰符别名：")])]),e._v(" "),r("h2",{attrs:{id:"为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx"}},[e._v("#")]),e._v(" 为什么我的引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx")]),e._v(" "),r("p",[e._v("这个是 webpack 里面的对应插件处理的."),r("br"),e._v("\n对于小于多少 K 以下的图片(规定的格式)直接转为 base64 格式渲染;"),r("br"),e._v("\n具体配置在 webpack.base.conf.js 里面的 rules 里面的 url-loader"),r("br"),e._v("\n这样做的好处:在网速不好的时候先于内容加载和减少 http 的请求次数来减少网站服务器的负担。")]),e._v(" "),r("h2",{attrs:{id:"component-template-shold-contain-exactly-one-root-element-if-you-are-useing-v-if-on-multiple-elements-xxxxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#component-template-shold-contain-exactly-one-root-element-if-you-are-useing-v-if-on-multiple-elements-xxxxx"}},[e._v("#")]),e._v(" Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx")]),e._v(" "),r("p",[e._v("大体就是说,单组件渲染 DOM 区域必须要有一个根元素,"),r("br"),e._v("\n可以用 v-if 和 v-else-if 指令来控制其他元素达到并存的状态")]),e._v(" "),r("h2",{attrs:{id:"跨域问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跨域问题"}},[e._v("#")]),e._v(" 跨域问题")]),e._v(" "),r("p",[e._v("比如 No 'Access-Control-Allow-Origin' header is present on the requested resource."),r("br"),e._v("\n这种问题老生常谈了,我就不细说了,大体说一下;")]),e._v(" "),r("ol",[r("li",[r("strong",[e._v("CORS")]),e._v(" , 前后端都要对应去配置,IE10+ 2: nginx 反向代理,一劳永逸 <-- 线上环境可以用这个\n线下开发模式,比如你用了 vue-cli, 里面的 webpack 有引入了 proxyTable 这么个玩意, 也可以做接口反向代理")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// Vue-cli 2.X 在 config 目录下的index.js\n\nproxyTable: {\n  \"/bp-api\": {\n    target: \"http://new.d.st.cn\",\n    changeOrigin: true,\n    // pathRewrite: {\n    //   \"^/bp-api\": \"/\"\n    // }\n  }\n}\n\n\n// Vue-cli 3.x 需要再vue.config.js 里边配置\n devServer: {\n    proxy: {\n      '/api': {\n        target: 'http://xxxx/device/', //对应自己的接口\n        changeOrigin: true,\n        ws: true,\n        pathRewrite: {\n          '^/api': ''\n        }\n      }\n    }\n  }\n\n\n// target : 就是 api 的代理的实际路径\n// changeOrigin: 就是是变源,必须是,\n// pathRewrite : 就是路径重定向,一看就知道\n\n")])])]),r("h2",{attrs:{id:"我需要遍历的数组值更新了-值也赋值了-为什么视图不更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我需要遍历的数组值更新了-值也赋值了-为什么视图不更新"}},[e._v("#")]),e._v(" 我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!")]),e._v(" "),r("p",[e._v("那是因为有局限性啊,官方文档也说的很清楚,"),r("br"),e._v("\n只有一些魔改的之后的方法提供跟原生一样的使用姿势(可以触发视图更新);"),r("br"),e._v("\n一般我们更常用(除了魔改方法)的手段是使用:this.$set(obj,item,value);"),r("br"),e._v(" "),r("strong",[e._v("传送门:")]),r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B",title:"触发视图更新",target:"_blank"}},[e._v("触发视图更新")])]),e._v(" "),r("h2",{attrs:{id:"为什么我的组件间的样式不能继承或者覆写啊"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么我的组件间的样式不能继承或者覆写啊"}},[e._v("#")]),e._v(" 为什么我的组件间的样式不能继承或者覆写啊!")]),e._v(" "),r("p",[e._v("单组件开发模式下,请确认是否开启了 CSS 模块化功能!!这也是为了避免你与其他页面的命名冲突，导致样式错乱"),r("br"),e._v("\n也就是 scoped(vue-cli 里面配置了,只要加入这个属性就自动启用)")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<style lang="scss" scoped></style>\n')])])]),r("ul",[r("li",[e._v("PS：想用一用的样式也是可以的，写一个全局的 css，里面写一些公用的样式，需要的时候引用即可")])]),e._v(" "),r("h2",{attrs:{id:"路由模式改为-history-后-除了首次启动首页没报错-刷新访问路由都报错"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由模式改为-history-后-除了首次启动首页没报错-刷新访问路由都报错"}},[e._v("#")]),e._v(" 路由模式改为 history 后,除了首次启动首页没报错,刷新访问路由都报错!")]),e._v(" "),r("p",[e._v("必须给对应的服务端配置查询的主页面,也可以认为是主路由入口的引导"),r("br"),e._v("\n官方文档也有,为毛总有人不喜欢去看文档,总喜欢做伸手党,FUCK"),r("br"),e._v(" "),r("strong",[e._v("传送门:")]),e._v(" "),r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6",title:"Vue-Router history Mode",target:"_blank"}},[e._v("Vue-Router history Mode")])]),e._v(" "),r("h2",{attrs:{id:"我想拦截页面-或者在页面进来之前做一些事情-可以么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我想拦截页面-或者在页面进来之前做一些事情-可以么"}},[e._v("#")]),e._v(" 我想拦截页面,或者在页面进来之前做一些事情,可以么?")]),e._v(" "),r("p",[e._v("Of course !! 各种路由器的钩子!! "),r("br"),e._v(" "),r("strong",[e._v("传送门:")]),e._v(" "),r("a",{attrs:{href:"https://router.vuejs.org/zh/guide/advanced/navigation-guards.html",title:"导航守卫",target:"_blank"}},[e._v("导航守卫")]),r("br"),e._v("\n当然,记忆滚动的位置也可以做到,详情翻翻里面的文档")]),e._v(" "),r("h2",{attrs:{id:"typeerror-xxx-is-not-a-function"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typeerror-xxx-is-not-a-function"}},[e._v("#")]),e._v(" TypeError: xxx is not a function")]),e._v(" "),r("p",[e._v("这种问题明显就是写法有问题!!")]),e._v(" "),r("h2",{attrs:{id:"能不能跨级拿到-props"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#能不能跨级拿到-props"}},[e._v("#")]),e._v(" 能不能跨级拿到 props")]),e._v(" "),r("p",[e._v("这种情况是面向嵌套层次很深的组件，又要拿到上层的父传递的东东，"),r("br")]),e._v(" "),r("p",[e._v("可以用 "),r("strong",[e._v("$attrs")]),e._v(" 或者 "),r("strong",[e._v("inject + provide")]),e._v(" 来实现")]),e._v(" "),r("h2",{attrs:{id:"uncaught-referenceerror-xxx-is-not-define"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#uncaught-referenceerror-xxx-is-not-define"}},[e._v("#")]),e._v(" Uncaught ReferenceError: xxx is not define")]),e._v(" "),r("ul",[r("li",[e._v("实例内的 data 对应的变量没有声明")]),e._v(" "),r("li",[e._v("你导入模块报这个错误,那绝逼是导出没写好")])]),e._v(" "),r("h2",{attrs:{id:"error-in-render-function-type-error-cannot-read-property-xxx-of-undefined"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#error-in-render-function-type-error-cannot-read-property-xxx-of-undefined"}},[e._v("#")]),e._v(" Error in render function:\"Type Error: Cannot read property 'xxx' of undefined\"")]),e._v(" "),r("p",[e._v("这种问题大多都是初始化的姿势不对;"),r("br"),e._v("\n比如引入"),r("strong",[e._v("echart")]),e._v("这些,仔细去了解下生命周期,再来具体初始化;"),r("br"),e._v("\nvue 组件有时候也会(嵌套组件或者 "),r("strong",[e._v("props")]),e._v("传递初始化),也是基本这个问题")]),e._v(" "),r("h2",{attrs:{id:"unexpected-token-operator-xxxxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unexpected-token-operator-xxxxx"}},[e._v("#")]),e._v(" Unexpected token: operator xxxxx")]),e._v(" "),r("p",[e._v("语法错误啊. 基本都是符号问题. 一般报错会给出哪一行或者哪个组件")]),e._v(" "),r("h2",{attrs:{id:"操作-vue-的原型链好么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#操作-vue-的原型链好么"}},[e._v("#")]),e._v(" 操作 Vue 的原型链好么")]),e._v(" "),r("p",[e._v("这个问题需要具体情况具体分析；"),r("br"),e._v("\n我看很多人喜欢把 axios 挂载到 Vue.prototype 上；"),r("br"),e._v("\n这样做有一定的弊端，相当耦合，若是多人维护或者替换其他库的时候有一定困难；"),r("br"),e._v("\n比较好的做法是不挂载，而是单独有服务请求的文件，用函数来封装你所需要的接口聚合；"),r("br"),e._v("\n这样统一暴露函数名，而内部实现可以随便改动")]),e._v(" "),r("h2",{attrs:{id:"cssbackground-引入图片打包后-访问路径错误"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cssbackground-引入图片打包后-访问路径错误"}},[e._v("#")]),e._v(" CSSbackground 引入图片打包后,访问路径错误")]),e._v(" "),r("p",[e._v("因为打包后图片是在根目录下,你用相对路径肯定报错啊,. 你可以魔改 webpack 的配置文件里面的 static 为./static,但是不建议"),r("br"),e._v("\n你若是把图片什么丢到 assets 目录下,然后相对路径,打包后是正常的")]),e._v(" "),r("h2",{attrs:{id:"安装模块时命令窗口输出-unsupported-platform-xxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装模块时命令窗口输出-unsupported-platform-xxx"}},[e._v("#")]),e._v(" 安装模块时命令窗口输出 unsupported platform xxx")]),e._v(" "),r("p",[e._v("一般两种情况,node 版本不兼容,系统不兼容;"),r("br"),e._v("\n解决方案: 要么不装,要么满足安装要求;")]),e._v(" "),r("h2",{attrs:{id:"unexpected-tab-charater"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unexpected-tab-charater"}},[e._v("#")]),e._v(" Unexpected tab charater")]),e._v(" "),r("p",[e._v("一般是你用脚手架初始化的时候开了 eslint ;"),r("br"),e._v("\n要么遵循规则,要么改变规则;"),r("br"),e._v("\n要么直接把 webpack 里面的 eslint 检测给关闭了")]),e._v(" "),r("h2",{attrs:{id:"failed-to-mount-component-template-or-render-function-not-defined"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#failed-to-mount-component-template-or-render-function-not-defined"}},[e._v("#")]),e._v(" Failed to mount component: template or render function not defined")]),e._v(" "),r("p",[e._v("组件挂载失败,问题只有这么几个，组件没有正确引入或挂载点顺序错了了。")]),e._v(" "),r("h2",{attrs:{id:"unknown-custom-element-xxx-did-you-register-the-component-correctly"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unknown-custom-element-xxx-did-you-register-the-component-correctly"}},[e._v("#")]),e._v(" Unknown custom element: xxx - did you register the component correctly")]),e._v(" "),r("p",[e._v("组件没有正确引入或者正确使用,依次确认:\n如何让自定义组件支持 Vue.use 使用呢")]),e._v(" "),r("ol",[r("li",[e._v("导入对应的组件")]),e._v(" "),r("li",[e._v("在 components 内声明")]),e._v(" "),r("li",[e._v("在 dom 区域声明标签")])]),e._v(" "),r("h2",{attrs:{id:"如何让自定义组件支持-vue-use-使用呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何让自定义组件支持-vue-use-使用呢"}},[e._v("#")]),e._v(" 如何让自定义组件支持 Vue.use 使用呢")]),e._v(" "),r("p",[e._v("只要暴露一个 install 函数即可，大体可以看下以下代码；")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import BtnPopconfirm from './BtnPopconfirm.vue';\nBtnPopconfirm.install = function(Vue) {\n  Vue.component(BtnPopconfirm.name, BtnPopconfirm);\n};\nexport default BtnPopconfirm;\n")])])]),r("h2",{attrs:{id:"axios-的-post-请求后台接受不到"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#axios-的-post-请求后台接受不到"}},[e._v("#")]),e._v(" axios 的 post 请求后台接受不到")]),e._v(" "),r("p",[e._v("axios 默认是 json 格式提交,确认后台是否做了对应的支持;"),r("br"),e._v("\n若是只能接受传统的表单序列化,就需要自己写一个转义的方法,"),r("br"),e._v("\n当然还有一个更加省事的方案,装一个小模块 qs")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// npm install qs -S\n// 然后在对应的地方转就行了,单一请求也行,拦截器也行,我是写在拦截器的.\n// 具体可以看看我 axios 封装那篇文章\n\n//POST传参序列化(添加请求拦截器)\nAxios.interceptors.request.use(\n  config => {\n    // 在发送请求之前做某件事\n    if (\n      config.method === "post"\n    ) {\n      // 序列化\n      config.data = qs.stringify(config.data); // ***** 这里转义\n    }\n\n    // 若是有做鉴权token , 就给头部带上token\n    if (localStorage.token) {\n      config.headers.Authorization = localStorage.token;\n    }\n    return config;\n  },\n  error => {\n    Message({\n      //  饿了么的消息弹窗组件,类似toast\n      showClose: true,\n      message: error,\n      type: "error.data.error.message"\n    });\n    return Promise.reject(error.data.error.message);\n  }\n);\n\n')])])]),r("h2",{attrs:{id:"vue-支持-jsx-的写法么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-支持-jsx-的写法么"}},[e._v("#")]),e._v(" Vue 支持 jsx 的写法么")]),e._v(" "),r("p",[e._v("可以很确定的告诉你，是支持的；\n但是和 React 是有所差异的，而非完全等同的，具体可以看官方的支持库("),r("a",{attrs:{href:"github.com/vuejs/jsx",title:"github.com/vuejs/jsx",target:"_blank"}},[e._v("github.com/vuejs/jsx")]),e._v("\n)")]),e._v(" "),r("h2",{attrs:{id:"invalid-prop-type-check-failed-for-prop-xxx-expected-boolean-got-string"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#invalid-prop-type-check-failed-for-prop-xxx-expected-boolean-got-string"}},[e._v("#")]),e._v(' Invalid prop: type check failed for prop "xxx". Expected Boolean, got String.')]),e._v(" "),r("p",[e._v("这种问题一般就是组件内的 props 类型已经设置了接受的范围类型, 而你传递的值却又不是它需要的类型")]),e._v(" "),r("h2",{attrs:{id:"过滤器可以用于-dom-区域结合指令么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过滤器可以用于-dom-区域结合指令么"}},[e._v("#")]),e._v(" 过滤器可以用于 DOM 区域结合指令么?")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// 不行,看下面的错误例子\n<li v-for="(item,index) in range | sortByDesc | spliceText">{{item}}</li>\n\n// `vue2+`的指令只能用语 mustache`{{}}` , 正确姿势如下:\n\n<span>{{ message | capitalize }}</span>\n\n')])])]),r("h2",{attrs:{id:"array-mapstate-some-mutation-increment-commit-这种写法是什么鬼"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#array-mapstate-some-mutation-increment-commit-这种写法是什么鬼"}},[e._v("#")]),e._v(" [,Array],,mapState,"),r("a",{attrs:{href:"state"}},[e._v("SOME_MUTATION")]),e._v(" {},increment ({ commit }) {}这种写法是什么鬼!")]),e._v(" "),r("p",[e._v("出门左拐,ES6+(ES2015+)的基础去过一遍,"),r("br"),e._v("\n上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递")]),e._v(" "),r("h2",{attrs:{id:"我的-vue-网站为什么-uc-访问一片空白亦或者-flex-布局错乱"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我的-vue-网站为什么-uc-访问一片空白亦或者-flex-布局错乱"}},[e._v("#")]),e._v(" 我的 Vue 网站为什么 UC 访问一片空白亦或者 flex 布局错乱!!")]),e._v(" "),r("p",[e._v("来来来,墙角走起,. UC 号称移动界的 IE 这称号不是白叫的")]),e._v(" "),r("ul",[r("li",[e._v("flexbox 布局错乱,一般是你没有把兼容方案写上,就是带各种前缀,复合属性拆分，引入 autoprefixer, 写上兼容范围就好了.")]),e._v(" "),r("li",[e._v("UC 访问空白, 有一种情况绝对会造成,那就是 ES6 的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)")]),e._v(" "),r("li",[e._v("现在的开发都推荐按需引入,靠 babel-preset-env 来控制,以达到打包体积减小.")]),e._v(" "),r("li",[e._v("但是这样做的后果,有些内核比较老的,嘿嘿,拜拜,")]),e._v(" "),r("li",[e._v("所以最好把代码完全 ES5 化!!记住有些特性不能乱使用,没有对应的 polyfill,比如 ES6 的 proxy")])]),e._v(" "),r("h2",{attrs:{id:"this-set-this-xxx-这个-是个什么意思-是-jquery-的么-会冲突么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#this-set-this-xxx-这个-是个什么意思-是-jquery-的么-会冲突么"}},[e._v("#")]),e._v(" this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery 的么,会冲突么?")]),e._v(" "),r("ul",[r("li",[e._v("Vue 的$和 jQuery 的$并没有半毛钱的关系,就跟 javascript 和 java 一样.")]),e._v(" "),r("li",[e._v("Vue 的$是封装了一些 vue 的内建函数,然后导出以$开头,这显然并不是 jQuery 的专利;")]),e._v(" "),r("li",[e._v("jQuery 的$是选择器!!取得 DOM 区域,两者的作用完全不一致!")])]),e._v(" "),r("h2",{attrs:{id:"module-not-found-error-can-t-resolve-xxx-loader-in-xxxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#module-not-found-error-can-t-resolve-xxx-loader-in-xxxx"}},[e._v("#")]),e._v(" Module not found: Error : Can't resolve 'xxx-loader' in xxxx")]),e._v(" "),r("p",[e._v("这里问题一般就是 webpack 的配置文件你改动了或对应的 loader 没有装上")]),e._v(" "),r("h2",{attrs:{id:"父组件可以直接调用子组件的方法么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#父组件可以直接调用子组件的方法么"}},[e._v("#")]),e._v(" 父组件可以直接调用子组件的方法么!")]),e._v(" "),r("p",[e._v("可以,通过 "),r("strong",[e._v("$refs")]),e._v(" 或者 "),r("strong",[e._v("$chilren")]),e._v("来拿到对应的实例,从而操作")]),e._v(" "),r("h2",{attrs:{id:"error-in-event-handler-for-click-xxx"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#error-in-event-handler-for-click-xxx"}},[e._v("#")]),e._v(' Error in event handler for "click":"xxx"')]),e._v(" "),r("p",[e._v("这个问题大多都是你写的代码有问题.你的事件触发了. 但是组件内部缺少对应的实现或者变量,所以抛出事件错误.")]),e._v(" "),r("h2",{attrs:{id:"组件的通讯有哪几种啊"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件的通讯有哪几种啊"}},[e._v("#")]),e._v(" 组件的通讯有哪几种啊!")]),e._v(" "),r("p",[e._v("基本最常用的是这三种：")]),e._v(" "),r("ol",[r("li",[e._v("父传子: props")]),e._v(" "),r("li",[e._v("子传父: emit")]),e._v(" "),r("li",[e._v("兄弟通讯:")])]),e._v(" "),r("ul",[r("li",[e._v("event bus: 就是找一个中间组件来作为信息传递中介")]),e._v(" "),r("li",[e._v("vuex: 信息树"),r("br"),r("br"),e._v(" "),r("strong",[e._v("传送门:")])]),e._v(" "),r("li",[r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html",title:"基本通讯",target:"_blank"}},[e._v("基本通讯")])]),e._v(" "),r("li",[r("a",{attrs:{href:"https://vuex.vuejs.org/zh/guide/",title:"Vuex",target:"_blank"}},[e._v("Vuex")])])]),e._v(" "),r("h2",{attrs:{id:"既然-localstorage-和-sessionstorage-能做到数据维护-为什么还要引入-vuex"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#既然-localstorage-和-sessionstorage-能做到数据维护-为什么还要引入-vuex"}},[e._v("#")]),e._v(" 既然 localStorage 和 sessionStorage 能做到数据维护,为什么还要引入 vuex")]),e._v(" "),r("p",[e._v("这个问题问得好,Vuex 的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;"),r("br"),e._v("\n仅仅活在 SPA 的里面的 "),r("strong",[e._v("伪多页(路由)")]),e._v(" 内, 这种东东明明然 "),r("strong",[e._v("localStorage")]),e._v(" 和 "),r("strong",[e._v("sessionStorage")]),e._v(" 也可以做到,还能做到跨页面数据维护,还不会被浏览器刷新干掉,"),r("br"),e._v("\n为什么还要引入 "),r("strong",[e._v("vuex")]),e._v(' , 我个人觉得原因只有这么一个,"可维护性"和"易用性"及'),r("br"),e._v("\n怎么理解呢?"),r("br")]),e._v(" "),r("ul",[r("li",[e._v("可维护性: 因为是单向数据流,所有状态是有迹可循的,数据的传递也可以及时分发响应")]),e._v(" "),r("li",[e._v("易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯\n"),r("br")])]),e._v(" "),r("p",[e._v("而且代码量不多,若是你要用 "),r("strong",[e._v("ls")]),e._v(" 或者 "),r("strong",[e._v("ss")]),e._v(" ,你必须手动去跟踪维护你的状态表, 虽说可行,但是代码量会多很多,而且可读性很差,"),r("br"),e._v("\n是不是每个项目都需要用到 vuex? 答案是否定的,小型项目上这个反而是累赘,这东西一般是用在中型项目+的, 因为里面涉及需要维护的数据比较多,同组件间的通讯比较频繁"),r("br"),e._v("\n若是用到 "),r("strong",[e._v("vuex")]),e._v(" 的项目记得结合 "),r("strong",[e._v("ss")]),e._v(" 或者 "),r("strong",[e._v("ls")]),e._v(" 来达到某些状态持久化!为什么看下面!")]),e._v(" "),r("h2",{attrs:{id:"vuex-的用户信息为什么还要存一遍在浏览器里-sessionstorage-或-localstorage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuex-的用户信息为什么还要存一遍在浏览器里-sessionstorage-或-localstorage"}},[e._v("#")]),e._v(" vuex 的用户信息为什么还要存一遍在浏览器里(sessionStorage 或 localStorage)")]),e._v(" "),r("p",[e._v("因为 "),r("strong",[e._v("vuex")]),e._v(" 的 "),r("strong",[e._v("store")]),e._v(" 干不过刷新啊. 保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗")]),e._v(" "),r("h2",{attrs:{id:"npm-run-dev-报端口错误-error-listen-eaddrinuse-8080"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#npm-run-dev-报端口错误-error-listen-eaddrinuse-8080"}},[e._v("#")]),e._v(" npm run dev 报端口错误!Error: listen EADDRINUSE :::8080")]),e._v(" "),r("ul",[r("li",[e._v("自己用 webpack 搭脚手架的都不用我说了;")]),e._v(" "),r("li",[e._v("Vue-cli 里面的 webpack 配置: config/index.js")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('  dev: {\n    env: require("./dev.env"),\n    port: 8080, //  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!\n    autoOpenBrowser: true,\n    assetsSubDirectory: "static",\n    assetsPublicPath: "/",\n    proxyTable: {\n      "/bp-api": {\n        target: "http://new.d.st.cn",\n        changeOrigin: true,\n        // pathRewrite: {\n        //   "^/bp-api": "/"\n        // }\n      }\n    },\n\n')])])]),r("h2",{attrs:{id:"什么时候用-v-if-什么用-v-show"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么时候用-v-if-什么用-v-show"}},[e._v("#")]),e._v(" 什么时候用 v-if,什么用 v-show!")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("v-if")]),e._v(" : DOM 区域没有生成,没有插入文档,等条件成立的时候才动态插入到页面!\n有些需要遍历的数组对象或者值,最好用这货控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!")]),e._v(" "),r("li",[r("strong",[e._v("v-show")]),e._v(" : DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了\n对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了,而且可以改善用户体验,因为它不会导致页面的重绘,DOM 操作会!\n简言之: DOM 结构不怎么变化的用 "),r("strong",[e._v("v-show")]),e._v(" , 数据需要改动很大或者布局改动的用 "),r("strong",[e._v("v-if")])])]),e._v(" "),r("h2",{attrs:{id:"template-是什么-html5-的标签么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#template-是什么-html5-的标签么"}},[e._v("#")]),e._v(" <template>是什么,html5 的标签么?")]),e._v(" "),r("p",[e._v("html5 的标签还真有这么一个."),r("strong",[e._v("传送门")]),r("a",{attrs:{href:"https://caniuse.com/#search=template",title:"template",target:"_blank"}},[e._v("template")]),r("br"),e._v("\n不过 "),r("strong",[e._v("Vue")]),e._v(" 的 "),r("strong",[e._v("template")]),e._v(" 有点不一样,不是去给浏览器解析的,. 你可以理解为一个临时标签,用来方便你写循环,判断的,. 因为最终 "),r("strong",[e._v("template")]),e._v(" 不会解析到浏览器的页面,他只是在 "),r("strong",[e._v("Vue")]),e._v(" 解析的过程充当一个包裹层! 最终我们看到的是内部处理后的组合的 "),r("strong",[e._v("DOM")]),e._v(" 结构!")]),e._v(" "),r("h2",{attrs:{id:"vue-支持类似-react-的-props-么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-支持类似-react-的-props-么"}},[e._v("#")]),e._v(" Vue 支持类似 React 的{,props}么")]),e._v(" "),r("p",[e._v('jsx 的写法肯定是支持的，常规的写法也支持，用 v-bind="propsObject"会自动展开')]),e._v(" "),r("h2",{attrs:{id:"uncaught-referenceerror-vue-is-not-defined"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#uncaught-referenceerror-vue-is-not-defined"}},[e._v("#")]),e._v(" Uncaught ReferenceError : Vue is not defined!")]),e._v(" "),r("p",[e._v("依次排除:")]),e._v(" "),r("ul",[r("li",[e._v("Vue 是否正确引入!")]),e._v(" "),r("li",[e._v("Vue 是否正确实例化!")]),e._v(" "),r("li",[e._v("Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!刚好又没定义,,具体问题具体分析吧)")])]),e._v(" "),r("h2",{attrs:{id:"error-in-static-js-xxxxxxx-js-from-uglifyjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#error-in-static-js-xxxxxxx-js-from-uglifyjs"}},[e._v("#")]),e._v(" ERROR in static/js/xxxxxxx.js from UglifyJs")]),e._v(" "),r("p",[e._v("我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(xxx.min.js); 然后 "),r("strong",[e._v("webpack")]),e._v(" 内又启用了 "),r("strong",[e._v("UglifyJs")]),e._v(" (压缩 JS 的), 二重压缩大多都会报错!!"),r("br")]),e._v(" "),r("p",[e._v("解决方案:引入标准未压缩的 JS")]),e._v(" "),r("h2",{attrs:{id:"props-不使用-v-bind-可以传递值么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#props-不使用-v-bind-可以传递值么"}},[e._v("#")]),e._v(" props 不使用:(v-bind)可以传递值么!")]),e._v(" "),r("p",[e._v("可以,只是默认传递的类型会被解析成字符串! 若是要传递其他类型,该绑定还是绑定!!")]),e._v(" "),r("h2",{attrs:{id:"uncaught-typeerror-cannot-set-property-xxx-which-has-only-a-getter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#uncaught-typeerror-cannot-set-property-xxx-which-has-only-a-getter"}},[e._v("#")]),e._v(" Uncaught TypeError : Cannot set property xxx which has only a getter")]),e._v(" "),r("p",[e._v("这个问题就是你要操作的属性只允许 getter,不允许 setter;"),r("br"),e._v("\n解决方案? 用了别人的东西就要遵循别人的套路来,不然就只能自己动手丰衣足食了!!")]),e._v(" "),r("h2",{attrs:{id:"单组件中里面的-import-xxx-from-components-layout-xxx-中的-是什么鬼"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单组件中里面的-import-xxx-from-components-layout-xxx-中的-是什么鬼"}},[e._v("#")]),e._v(" 单组件中里面的 import xxx from '@/components/layout/xxx'中的@是什么鬼!")]),e._v(" "),r("p",[e._v("这是 webpack 方面的知识,看到了也说下吧,"),r("br"),e._v("\nwebpack 可以配置 alias(也就是路径别名),玩过 linux 或者 mac 都知道"),r("br"),e._v("\n依旧如上,会自己搭脚手架的不用我说了,看看 vue-cli 里面的;"),r("br"),e._v("\n文件名: build -> webpack.base.conf.js")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v(' resolve: {\n    extensions: [".js", ".vue", ".json"], // 可以导入的时候忽略的拓展名范围\n    alias: {\n      vue$: "vue/dist/vue.esm.js",\n      "@": resolve("src"),  // 这里就是别名了,比如@就代表直接从/src 下开始找起!\n      "~": resolve("src/components")\n    }\n  },\n\n')])])]),r("h2",{attrs:{id:"scss-sass-还是-less-stylus-好"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#scss-sass-还是-less-stylus-好"}},[e._v("#")]),e._v(" SCSS(SASS) 还是 less,stylus 好!!")]),e._v(" "),r("p",[e._v("scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊."),r("br"),e._v("\n这三个都差不多,会其中一个其他两个的粗浅用法基本也会了.不过!!"),r("br")]),e._v(" "),r("p",[e._v("写法有些差异:")]),e._v(" "),r("ul",[r("li",[e._v("scss: 写法上是向 css 靠齐")]),e._v(" "),r("li",[e._v("sass : 其实也就是 scss , 只是写法不一样,靠的是缩进")]),e._v(" "),r("li",[e._v("less : 跟 css 基本靠齐")]),e._v(" "),r("li",[e._v("stylus : 一样,靠缩进,跟 pug(Jade)一样")])]),e._v(" "),r("br"),e._v("\n使用环境差异：\n"),r("ul",[r("li",[e._v("scss 可以借助 ruby 或者 node-sass 或者 dart-sass 编译")]),e._v(" "),r("li",[e._v("less 可以用 less.js 或者对应的 loader 解析")]),e._v(" "),r("li",[e._v("stylus 只能借助 loader 解析,它的出现就是基于 node 的\n也有一个后起之秀,主打解耦,插件化的! 那就是 PostCSS,这个是后处理器! 有兴趣的可以自行去了解,上面的写法都能借助插件实现!")])]),e._v(" "),r("h2",{attrs:{id:"failed-to-compile-with-x-errors-this-dependency-was-not-found"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#failed-to-compile-with-x-errors-this-dependency-was-not-found"}},[e._v("#")]),e._v(" Failed to compile with x errors : This dependency was not found !")]),e._v(" "),r("p",[e._v("编译错误,对应的依赖没找到!"),r("br"),e._v("\n解决如下:")]),e._v(" "),r("ul",[r("li",[e._v("知道缺少对应的模块,直接装进去")]),e._v(" "),r("li",[e._v("若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!")])]),e._v(" "),r("h2",{attrs:{id:"syntaxerror-unexpected-identifier"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syntaxerror-unexpected-identifier"}},[e._v("#")]),e._v(" SyntaxError: Unexpected identifier")]),e._v(" "),r("p",[e._v("语法错误,看错误信息去找到对应的页面排查!")]),e._v(" "),r("h2",{attrs:{id:"为什么我的-npm-或者-yarn-安装依赖会生成-lock-文件-有什么用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么我的-npm-或者-yarn-安装依赖会生成-lock-文件-有什么用"}},[e._v("#")]),e._v(" 为什么我的 npm 或者 yarn 安装依赖会生成 lock 文件,有什么用!")]),e._v(" "),r("p",[r("strong",[e._v("lock")]),e._v(" 文件的作用是统一版本号,这对团队协作有很大的作用;"),r("br"),e._v("\n若是没有 "),r("strong",[e._v("lock")]),e._v(" 锁定,根据 package.json 里面的^,~这些,"),r("br"),e._v("\n不同人,不同时间安装出来的版本号不一定一致;"),r("br"),e._v("\n有些包甚至有一些 breaking change(破坏性的更新),造成开发很难顺利进行!")]),e._v(" "),r("h2",{attrs:{id:"组件可以缓存么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件可以缓存么"}},[e._v("#")]),e._v(" 组件可以缓存么")]),e._v(" "),r("p",[e._v("可以,用 "),r("strong",[e._v("keep-alive")]),e._v(" ;"),r("br"),e._v("\n不过是有代价的,占有内存会多了,所以无脑的缓存所有组件!别说性能好了,切换几次, 有些硬件 hold 不住的,浏览器直接崩溃或者卡死,"),r("br"),e._v("\n所以 "),r("strong",[e._v("keep-alive")]),e._v(" 一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换,"),r("br"),e._v("\n给路由的组件 meta 增加一个标志位,结合 v-if 就可以按需加上缓存了!")]),e._v(" "),r("h2",{attrs:{id:"package-json-里面的-dependencies-和-devdependencies-的差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#package-json-里面的-dependencies-和-devdependencies-的差异"}},[e._v("#")]),e._v(" package.json 里面的 dependencies 和 devDependencies 的差异!")]),e._v(" "),r("p",[e._v("其实不严格的话,没有特别的差异; 若是严格,遵循官方的理解;")]),e._v(" "),r("ul",[r("li",[e._v("dependencies : 存放线上或者业务能访问的核心代码模块,比如 vue,vue-router;")]),e._v(" "),r("li",[e._v("devDependencies: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么 babel-core 这些")])]),e._v(" "),r("p",[e._v("如何把包安装到对应的依赖下呢?")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\nnpm install --save xxxx // dependencies\nnpm install --save-dev xxxx // devDependencies\n\n//也能用简易的写法(i:install,-S:save,-D:save-dev)\n\nnpm i -S xxxx // npm install --save xxxx\nnpm i -D xxxx // npm install --save-dev xxxx\n")])])]),r("h2",{attrs:{id:"安装-chromedriver-报错-姿势没错啊-npm-i-d-chromedriver"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装-chromedriver-报错-姿势没错啊-npm-i-d-chromedriver"}},[e._v("#")]),e._v(" 安装 chromedriver 报错!!姿势没错啊 npm i -D chromedriver")]),e._v(" "),r("p",[e._v("解决方案:指定国内的源安装就可以了\nnpm install --save-dev chromedriver "),r("br"),e._v("\n--chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver")]),e._v(" "),r("h2",{attrs:{id:"我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破"}},[e._v("#")]),e._v(" 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破")]),e._v(" "),r("p",[e._v("字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份 data;"),r("br"),e._v("\n有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译),"),r("br"),e._v("\n比如从编辑切到新增,data 必须为空白没有赋值的,等待我们去赋值;"),r("br"),e._v("\n这时候有个东西就特别适合了,那就是 "),r("strong",[e._v("immutable-js")]),e._v(";"),r("br"),e._v("\n这个东西可以模拟数据的唯一性!或者叫做不变性!")]),e._v(" "),r("h2",{attrs:{id:"首屏加载比较慢-怎么破-打包文件文件比较大"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#首屏加载比较慢-怎么破-打包文件文件比较大"}},[e._v("#")]),e._v(" 首屏加载比较慢!!怎么破!打包文件文件比较大")]),e._v(" "),r("p",[e._v("依次排除和确认:")]),e._v(" "),r("ul",[r("li",[e._v("减少第三方库的使用,比如 jquey 这些都可以不要了,很少操作 dom,而且原生基本满足开发")]),e._v(" "),r("li",[e._v("若是引入 moment 这些,webpack 排除国际化语言包")]),e._v(" "),r("li",[e._v("webpack 常规压缩 js,css, 愿意折腾的还可以引入 dll 这些")]),e._v(" "),r("li",[e._v("路由组件采用懒加载")]),e._v(" "),r("li",[e._v("加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!")])]),e._v(" "),r("br"),e._v("\n但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些; 直接返回一个 html ,还能 SEO\n### Vue你们如何做spa的模块懒加载呢\n"),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('// 推荐这种写法\n// 一来可以聚合webpackChunkName名字一样的为一个模块，也是当前版本推荐的加载姿势\nconst Home = () =>\n  import(/* webpackChunkName: "HomePage" */ "@/views/home/index.vue");\n\n')])])]),r("h2",{attrs:{id:"vue-spa-没法做优化-seo-有解决方案么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-spa-没法做优化-seo-有解决方案么"}},[e._v("#")]),e._v(" Vue SPA 没法做优化(SEO)!有解决方案么")]),e._v(" "),r("p",[e._v("可以的,ssr(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html"),r("br"),e._v("\n现在 vue 的服务端开发框架有这么个比较流行,如下\n"),r("br"),e._v(" "),r("strong",[e._v("传送门：")]),r("a",{attrs:{href:"https://zh.nuxtjs.org/",title:"Nuxt.js",target:"_blank"}},[e._v("Nuxt.js")]),e._v(" "),r("br"),e._v("\n也有官方的方案,"),r("a",{attrs:{href:"https://ssr.vuejs.org/zh/",title:"ssr 完全指南",target:"_blank"}},[e._v("ssr 完全指南")])]),e._v(" "),r("h2",{attrs:{id:"vue-周边库汇总"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-周边库汇总"}},[e._v("#")]),e._v(" Vue 周边库汇总")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/vuejs/awesome-vue",title:"Awesome Vue",target:"_blank"}},[e._v("Awesome Vue")]),e._v(": 里面收集了 Vue 方方面面的热门库!!")])])}),[],!1,null,null,null);t.default=s.exports}}]);
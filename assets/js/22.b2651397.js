(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{289:function(a,t,s){"use strict";s.r(t);var n=s(28),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"this-的那些问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-的那些问题"}},[a._v("#")]),a._v(" this 的那些问题")]),a._v(" "),s("blockquote",[s("p",[a._v("本文转自 https://juejin.im/post/5e88b054f265da47c35d7418")])]),a._v(" "),s("h2",{attrs:{id:"js-中-this-的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-中-this-的指向"}},[a._v("#")]),a._v(" js 中 this 的指向")]),a._v(" "),s("ul",[s("li",[a._v("在 ES5 中， this 的指向始终是一个原则：this 的指向并不是在创建的时候就可以确定的，在 es5 中， "),s("strong",[a._v("this 永远指向 最后调用它的那个对象")]),a._v(" 。")])]),a._v(" "),s("h3",{attrs:{id:"举几个栗子证明一下上述观点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#举几个栗子证明一下上述观点"}},[a._v("#")]),a._v(" 举几个栗子证明一下上述观点")]),a._v(" "),s("h4",{attrs:{id:"one"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#one"}},[a._v("#")]),a._v(" one")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var name = "globalName";\nfunction a() {\n  var name = "jingjing";\n  console.log(this.name)\n}\na();    //globalName\n')])])]),s("ul",[s("li",[a._v("根据刚刚上面那个原则： this 永远指向 最后调用它的那个对象 可以得到答案。我们看最后调用 a 的地方是在哪里？在最后一行代码 a(); 它前面没有调用的对象，那么就是默认的全局对象 window，所以 console.log(this.name)就变成了 console.log(window.name),结果输出的是 globalName（非严格模式下）。")])]),a._v(" "),s("h4",{attrs:{id:"two"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#two"}},[a._v("#")]),a._v(" two")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var name = "globalName";\nvar a = {\n  name: "jingjing",\n  jing: function () {\n    console.log(this.name);  // jingjing\n  }\n}\nwindow.a.jing();\n')])])]),s("ul",[s("li",[a._v("this 永远指向 最后调用它的那个对象 可以得到答案。我们看最后调用 jing() 函数 的地方是在哪里？或者说函数 jing() 左边这个.的左边的对象是哪个？显然是对象 a，所以 console.log(this.name)就变成了 console.log(a.name),结果输出的是 jingjing。")])]),a._v(" "),s("h4",{attrs:{id:"three"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#three"}},[a._v("#")]),a._v(" three")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('var name = "globalName";\nvar a = {\n  name: "jingjing",\n  jing: function () {\n    console.log(this.name);  // globalName\n  }\n}\nvar hao = a.jing\nhao();\n')])])]),s("ul",[s("li",[a._v("这里我们虽然将 a 对象的 jing 方法赋值给变量 hao 了，但是注意！！！🔍 这一步没有调用执行 jing 方法！。代码最后一行 hao() 才被 window 调用执行了 jing()方法。 所以 console.log(this.name)就变成了 console.log(window.name),结果输出的是 globalName。再拿出这个原则：this 永远指向最后调用它的那个对象。🌈🌈🌈")])]),a._v(" "),s("h2",{attrs:{id:"this-的四种绑定规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-的四种绑定规则"}},[a._v("#")]),a._v(" this 的四种绑定规则")]),a._v(" "),s("p",[a._v("在 JavaScript 中，this 指向的绑定规则有以下四种："),s("br")]),a._v(" "),s("ul",[s("li",[a._v("默认绑定（非严格模式情况下，this 指向 window, 严格模式下，this 指向 undefined。）")]),a._v(" "),s("li",[a._v("隐式绑定（如果函数调用时，前面存在调用它的对象，那么 this 就会隐式绑定到这个对象上）")]),a._v(" "),s("li",[a._v("显式绑定（函数通过 call()、apply()、bind()调用，this 指向被绑定的对象。）")]),a._v(" "),s("li",[a._v("new 绑定（函数被 new 调用，this 指向由 new 新构造出来的这个对象。）")])]),a._v(" "),s("h3",{attrs:{id:"上文对前两种已经有所理解，现在我们来聚光到后两种。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#上文对前两种已经有所理解，现在我们来聚光到后两种。"}},[a._v("#")]),a._v(" 上文对前两种已经有所理解，现在我们来聚光到后两种。")]),a._v(" "),s("h4",{attrs:{id:"显式绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#显式绑定"}},[a._v("#")]),a._v(" 显式绑定")]),a._v(" "),s("p",[a._v("这种绑定方式就是使用 Function.prototype 中的三个方法 call()， apply()，和 bind() 了。这三个函数，都可以改变函数的 this 指向到指定的对象，不同之处在于："),s("br")]),a._v(" "),s("ul",[s("li",[a._v("call() 和 apply() 都是 "),s("strong",[a._v("立即执行函数")]),a._v(" ，但是它们接受的参数的形式不同，具体如下")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("call(this, arg1, arg2, ...)   // 普通的参数\napply(this, [arg1, arg2, ...]) // 以数组形式接收\n")])])]),s("ul",[s("li",[a._v("而 bind() 则是 "),s("strong",[a._v("返回一个新的包装函数")]),a._v("，而不是立刻执行。bind()会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("bind(this, arg1, arg2, ...)\n")])])]),s("h4",{attrs:{id:"new-绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#new-绑定"}},[a._v("#")]),a._v(" new 绑定")]),a._v(" "),s("p",[a._v("使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。"),s("br")]),a._v(" "),s("ul",[s("li",[a._v("1.创建（或者说构造）一个全新的对象。")]),a._v(" "),s("li",[a._v("2.这个新对象会被执行[[Prototype]]连接。")]),a._v(" "),s("li",[a._v("3.这个新对象会绑定到函数调用的 this。")]),a._v(" "),s("li",[a._v("4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象")])]),a._v(" "),s("p",[s("strong",[a._v("在 JavaScript 中，new 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。在 JavaScript 中，所有的函数都可以被 new 调用，这 候这个函数一般会被称为 “构造函数”，实际上并不存在所谓“构造函数”，更确切的理解应该是对于函数的 “构造器调用模式”。")])]),a._v(" "),s("h2",{attrs:{id:"绑定规则的优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则的优先级"}},[a._v("#")]),a._v(" 绑定规则的优先级")]),a._v(" "),s("p",[s("strong",[a._v("new 绑定 > 显式绑定 > 隐式绑定 > 默认绑定")])]),a._v(" "),s("blockquote",[s("p",[a._v("毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。")])]),a._v(" "),s("h3",{attrs:{id:"one-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#one-2"}},[a._v("#")]),a._v(" one")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function jing() {\n  console.log(this.a);\n}\n\nvar obj1 = {\n  a: 10,\n  foo: jing\n};\n\nvar obj2 = {\n  a: 20,\n  foo: jing\n};\n\nobj1.foo();   //10\nobj2.foo();   //20\n\nobj1.foo.call(obj2);   //20\nobj2.foo.call(obj1);   //10\n")])])]),s("p",[a._v("由这个运行结果可知，上面代码块倒数两行通过 call() 方法改变了 this 的指向。所以可以得到 "),s("strong",[a._v("显式绑定 > 隐式绑定")]),a._v(" 这个结论。")]),a._v(" "),s("h3",{attrs:{id:"two-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#two-2"}},[a._v("#")]),a._v(" two")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("function jing() {\n  this.a = 'hao';\n}\n\nlet obj = {\n  a: 'jing'\n};\n// 1、bind\nconst Bar = jing.bind(obj);\n// 2、new\nconst bar = new Bar();\nconsole.log(obj.a, '--', bar.a) //jing -- hao\n")])])]),s("p",[a._v("上面代码块倒数第三行通过 bind() 方法改变了 this 的指向obj，由上面这个 bar.a 打印输出结果为 hao 可知，倒数第二行代码改变了this指向 jing()，所以可以得到"),s("strong",[a._v("new绑定 > 显式绑定")]),a._v("。")]),a._v(" "),s("h2",{attrs:{id:"es6的this与es5的this区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6的this与es5的this区别"}},[a._v("#")]),a._v(" es6的this与es5的this区别")]),a._v(" "),s("h3",{attrs:{id:"es5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es5"}},[a._v("#")]),a._v(" es5")]),a._v(" "),s("ul",[s("li",[a._v("全局环境下，"),s("strong",[a._v("this 始终指向全局对象（window）")]),a._v(", 无论是否严格模式")]),a._v(" "),s("li",[a._v("函数直接调用,指向的是调用的函数")])]),a._v(" "),s("h3",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" es6")]),a._v(" "),s("ul",[s("li",[a._v("指向的是调用它的上下级")]),a._v(" "),s("li",[a._v("es6箭头函数其实没有自己的this")])])])}),[],!1,null,null,null);t.default=e.exports}}]);
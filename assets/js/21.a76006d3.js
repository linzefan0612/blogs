(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{263:function(t,e,v){"use strict";v.r(e);var s=v(28),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"eventloop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[t._v("#")]),t._v(" EventLoop")]),t._v(" "),v("blockquote",[v("p",[t._v("本文转自 https://juejin.im/post/5e80595c518825739f6af6f4")])]),t._v(" "),v("h2",{attrs:{id:"event-loop-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-是什么"}},[t._v("#")]),t._v(" Event Loop 是什么")]),t._v(" "),v("blockquote",[v("p",[t._v('In computer science, the event loop is a programming construct or design pattern that waits for and dispatches events or messages in a program. The event loop works by making a request to some internal or external "event provider" (that generally blocks the request until an event has arrived), then calls the relevant event handler ("dispatches the event"). The event loop is also sometimes referred to as the message dispatcher, message loop, message pump, or run loop.')])]),t._v(" "),v("ul",[v("li",[t._v("上面这段是 Wikipedia 对 Event Loop 的解释，简单的来说就是 Event Loop 是一个程序结构，用于等待和分派消息和事件我个人的理解是 JS 中的 Event Loop 是浏览器或 Node 的一种协调 JavaScript 单线程运行时不会阻塞的一种机制。")])]),t._v(" "),v("h2",{attrs:{id:"进程和线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),v("ul",[v("li",[t._v("上文我说了 Event Loop 是单线程阻塞问题的一种解决机制，所以在正式开始前还是要先从进程和线程的角度来聊一聊。众所周知的一件事是，JavaScript 是一个单线程机制的语言，那我们先来看看进程和线程的定义：")])]),t._v(" "),v("h3",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("ol",[v("li",[t._v("进程：进程是 CPU 资源分配的最小单位")]),t._v(" "),v("li",[t._v("线程：线程是 CPU 调度的最小单位")])]),t._v(" "),v("ul",[v("li",[t._v("简单来说，进程简单理解就是我们平常使用的程序，如 QQ，浏览器，网盘等。进程拥有自己独立的内存空间地址，拥有一个或多个线程，而线程就是对进程粒度的进一步划分。")]),t._v(" "),v("li",[t._v("更通俗的来说，进程就像是一家工厂，多个工厂之间是独立存在的。而线程就像是工厂中的那些工人，共享资源，完成同一个大目标。")])]),t._v(" "),v("h2",{attrs:{id:"js-的单线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js-的单线程"}},[t._v("#")]),t._v(" JS 的单线程")]),t._v(" "),v("p",[t._v("很多人都知道的是，JavaScript 是一门动态的解释型的语言，具有跨平台性。在被问到 JavaScript 为什么是一门单线程的语言，有的人可能会这么回答：“语言特性决定了 JavaScript 是一个单线程语言，JavaScript 天生是一个单线程语言”，这只不过是一层糖衣罢了。")]),t._v(" "),v("p",[t._v("JavaScript 从诞生起就是单线程，原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。")]),t._v(" "),v("p",[t._v("准确的来说，我认为 JavaScript 的单线程是指 JavaScript 引擎是单线程的，JavaScript 的引擎并不是独立运行的，跨平台意味着 JavaScript 依赖其运行的宿主环境 --- 浏览器(大部分情况下是浏览器)。")]),t._v(" "),v("p",[t._v("浏览器需要渲染 DOM，JavaScript 可以修改 DOM 结构，JavaScript 执行时，浏览器 DOM 渲染停止。如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都操作 DOM，那么就会出现 DOM 冲突。")]),t._v(" "),v("p",[t._v("举个例子来说，在同一时刻执行两个 script 对同一个 DOM 元素进行操作，一个修改 DOM，一个删除 DOM，那这样话浏览器就会懵逼了，它就不知道到底该听谁的，会有资源竞争，这也是 JavaScript 单线程的原因之一。")]),t._v(" "),v("h2",{attrs:{id:"浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),v("h3",{attrs:{id:"浏览器的多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的多线程"}},[t._v("#")]),t._v(" 浏览器的多线程")]),t._v(" "),v("p",[t._v("之前说过，JavaScript 运行的宿主环境浏览器是多线程的。"),v("br"),t._v("\n以 Chrome 来说，我们可以通过 Chrome 的任务管理器来看看。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/22/17102b254e650521?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"avatar"}}),t._v("\n当你打开一个 Tab 页面的时候，就创建了一个进程。如果从一个页面打开了另一个页面，打开的页面和当前的页面属于同一站点的话，那么这个页面会复用父页面的渲染进程。")]),t._v(" "),v("h2",{attrs:{id:"浏览器主线程常驻线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器主线程常驻线程"}},[t._v("#")]),t._v(" 浏览器主线程常驻线程")]),t._v(" "),v("ol",[v("li",[t._v("GUI 渲染线程")])]),t._v(" "),v("ul",[v("li",[t._v("绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等")]),t._v(" "),v("li",[t._v("页面重绘和回流")]),t._v(" "),v("li",[t._v("与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("JS 引擎线程")])]),t._v(" "),v("ul",[v("li",[t._v("负责 JS 脚本代码的执行")]),t._v(" "),v("li",[t._v("负责准执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件")]),t._v(" "),v("li",[t._v("与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("事件触发线程")])]),t._v(" "),v("ul",[v("li",[t._v("负责将准备好的事件交给 JS 引擎线程执行")]),t._v(" "),v("li",[t._v("多个事件加入任务队列的时候需要排队等待(JS 的单线程)")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("定时器触发线程")])]),t._v(" "),v("ul",[v("li",[t._v("负责执行异步的定时器类的事件，如 setTimeout、setInterval")]),t._v(" "),v("li",[t._v("定时器到时间之后把注册的回调加到任务队列的队尾")])]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("HTTP 请求线程")])]),t._v(" "),v("ul",[v("li",[t._v("负责执行异步请求")]),t._v(" "),v("li",[t._v("主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行")])]),t._v(" "),v("h2",{attrs:{id:"浏览器端的-event-loop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器端的-event-loop"}},[t._v("#")]),t._v(" 浏览器端的 Event Loop")]),t._v(" "),v("p",[t._v("看到这里，总算是进入正题了，先讲讲浏览器端的 Event Loop 是什么样的。\n"),v("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/3/26/171129962f45270f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}}),t._v("\n上图是一张 JS 的运行机制图，Js 运行时大致会分为几个部分：")]),t._v(" "),v("ol",[v("li",[t._v("Call Stack：调用栈(执行栈)，所有同步任务在主线程上执行，形成一个执行栈，因为 JS 单线程的原因，所以调用栈中每次只能执行一个任务，当遇到的同步任务执行完之后，由任务队列提供任务给调用栈执行。")]),t._v(" "),v("li",[t._v("Task Queue：任务队列，存放着异步任务，当异步任务可以执行的时候，任务队列会通知主线程，然后该任务会进入主线程执行。任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中。")])]),t._v(" "),v("p",[v("br"),t._v("说到这里，Event Loop 也可以理解为：不断地从任务队列中取出任务执行的一个过程。")]),t._v(" "),v("h3",{attrs:{id:"同步任务和异步任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步任务和异步任务"}},[t._v("#")]),t._v(" 同步任务和异步任务")]),t._v(" "),v("p",[t._v("上文已经说过了 JavaScript 是一门单线程的语言，一次只能执行一个任务，如果所有的任务都是同步任务，那么程序可能因为等待会出现假死状态，这对于一个用户体验很强的语言来说是非常不友好的。")]),t._v(" "),v("p",[t._v("比如说向服务端请求资源，你不可能一直不停的循环判断有没有拿到数据，就好像你点了个外卖，点完之后就开始一直打电话问外卖有没有送到，外卖小哥都会抄着锅铲来打你(狗头)。因此，在 JavaScript 中任务有了同步任务和异步任务，异步任务通过注册回调函数，等到数据来了就通知主程序。")]),t._v(" "),v("h4",{attrs:{id:"概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),v("p",[t._v("简单的介绍一下同步任务和异步任务的概念。")]),t._v(" "),v("ol",[v("li",[t._v("同步任务：必须等到结果来了之后才能做其他的事情，举例来说就是你烧水的时候一直等在水壶旁边等水烧开，期间不做其他的任何事情。")]),t._v(" "),v("li",[t._v("异步任务：不需要等到结果来了才能继续往下走，等结果期间可以做其他的事情，结果来了会收到通知。举例来说就是你烧水的时候可以去做自己想做的事情，听到水烧开的声音之后再去处理。")])]),t._v(" "),v("p",[v("br"),t._v("从概念就可以看出来，异步任务从一定程度上来看比同步任务更高效一些，核心是提高了用户体验。")]),t._v(" "),v("h3",{attrs:{id:"event-loop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#event-loop"}},[t._v("#")]),t._v(" Event Loop")]),t._v(" "),v("p",[t._v("Event Loop 很好的调度了任务的运行，宏任务和微任务也知道了，现在我们就来看看它的调度运行机制。")]),t._v(" "),v("p",[t._v("JavaScript 的代码执行时，主线程会从上到下一步步的执行代码，同步任务会被依次加入执行栈中先执行，异步任务会在拿到结果的时候将注册的回调函数放入任务队列，当执行栈中的没有任务在执行的时候，引擎会从任务队列中读取任务压入执行栈(Call Stack)中处理执行。")]),t._v(" "),v("h4",{attrs:{id:"宏任务和微任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),v("p",[t._v("现在就有一个问题了，任务队列是一个消息队列，先进先出，那就是说，后来的事件都是被加在队尾等到前面的事件执行完了才会被执行。如果在执行的过程中突然有重要的数据需要获取，或是说有事件突然需要处理一下，按照队列的先进先出顺序这些是无法得到及时处理的。这个时候就催生了宏任务和微任务，微任务使得一些异步任务得到及时的处理。")]),t._v(" "),v("p",[t._v("曾经看到的一个例子很好，宏任务和微任务形象的来说就是：你去营业厅办一个业务会有一个排队号码，当叫到你的号码的时候你去窗口办充值业务(宏任务执行)，在你办理充值的时候你又想改个套餐(微任务)，这个时候工作人员会直接帮你办，不可能让你重新排队。")]),t._v(" "),v("p",[t._v("所以上文说过的异步任务又分为宏任务和微任务，JS 运行时任务队列会分为宏任务队列和微任务队列，分别对应宏任务和微任务。")]),t._v(" "),v("p",[t._v("先介绍一下(浏览器环境的)宏任务和微任务大致有哪些：")]),t._v(" "),v("ul",[v("li",[t._v("宏任务：")])]),t._v(" "),v("ol",[v("li",[t._v("script(整体的代码)")]),t._v(" "),v("li",[t._v("setTimeout")]),t._v(" "),v("li",[t._v("setInterval")]),t._v(" "),v("li",[t._v("I/O 操作")]),t._v(" "),v("li",[t._v("UI 渲染 (对这个笔者持保留意见)")])]),t._v(" "),v("ul",[v("li",[t._v("微任务：")])]),t._v(" "),v("ol",[v("li",[t._v("Promise.then")]),t._v(" "),v("li",[t._v("MutationObserver")])]),t._v(" "),v("h4",{attrs:{id:"事件运行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件运行顺序"}},[t._v("#")]),t._v(" 事件运行顺序")]),t._v(" "),v("ol",[v("li",[t._v("执行同步任务，同步任务不需要做特殊处理，直接执行(下面的步骤中遇到同步任务都是一样处理) --- 第一轮从 script 开始")]),t._v(" "),v("li",[t._v("从宏任务队列中取出队头任务执行")]),t._v(" "),v("li",[t._v("如果产生了宏任务，将宏任务放入宏任务队列，下次轮循的时候执行")]),t._v(" "),v("li",[t._v("如果产生了微任务，将微任务放入微任务队列")]),t._v(" "),v("li",[t._v("执行完当前宏任务之后，取出微任务队列中的所有任务依次执行")]),t._v(" "),v("li",[t._v("如果微任务执行过程中产生了新的微任务，则继续执行微任务，直到微任务的队列为空")]),t._v(" "),v("li",[t._v("轮循，循环以上 2 - 6\n总的来说就是：同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 同步任务/宏任务 -> 执行产生的所有微任务(包括微任务产生的微任务) -> 循环......")])]),t._v(" "),v("h4",{attrs:{id:"举个栗子"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#举个栗子"}},[t._v("#")]),t._v(" 举个栗子")]),t._v(" "),v("p",[t._v("光说不练假把式，现在就来看一个例子：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('console.log(\'script start\')\nsetTimeout(function() {\n  console.log(\'setTimeout\')\n}, 0)\nnew Promise((resolve, reject)=>{\n  console.log("promise1")\n  resolve()\n})\n.then(()=>{\n  console.log("then11")\n  new Promise((resolve, reject)=>{\n    console.log("promise2")\n    resolve();\n  })\n  .then(() => {\n    console.log("then2-1")\n  })\n  .then(() => {\n    console.log("then2-2")\n  })\n})\n.then(()=>{\n  console.log("then12")\n})\nconsole.log(\'script end\')\n')])])]),v("ol",[v("li",[t._v("首先遇到 console.log()，输出 "),v("strong",[t._v("script start")])]),t._v(" "),v("li",[t._v("遇到 setTimeout 产生宏任务，注册到宏任务队列[setTimeout]，下一轮 Event Loop 的时候在执行")]),t._v(" "),v("li",[t._v("然后遇到 new Promise 构造声明(同步)，log 输出 "),v("strong",[t._v("promise1")]),t._v("，然后 resolve")]),t._v(" "),v("li",[t._v("resolve 匹配到 promise1 的第一个 then，把这个 then 注册到微任务队列[then11]中，继续当前整体脚本的执行")]),t._v(" "),v("li",[t._v("遇到最后的一个 log，输出 "),v("strong",[t._v("script end")]),t._v("，当前执行栈清空")]),t._v(" "),v("li",[t._v("从微任务队列中取出队头任务'then11' 进行执行，其中有一个 log，输出 "),v("strong",[t._v("then11")])]),t._v(" "),v("li",[t._v("往下遇到 new Promise 构造声明(同步)，log 输出 "),v("strong",[t._v("promise2")]),t._v(" ，然后 resolve")]),t._v(" "),v("li",[t._v("resolve 匹配到 promise2 的第一个 then，把这个 then 注册到微任务队列[then2-1]，当前 then11 可执行部分结束，然后产生了 promise1 的第二个 then，把这个 then 注册到微任务队列[then2-1, then12]")]),t._v(" "),v("li",[t._v("拿出微任务队头任务'then2-1' 执行，log 输出 "),v("strong",[t._v("then2-1")]),t._v("，触发 promise2 的第二个 then，注册到微任务队列[then12, then2-2]")]),t._v(" "),v("li",[t._v("拿出微任务队头任务'then12'，log 输出 "),v("strong",[t._v("then12")])]),t._v(" "),v("li",[t._v("拿出微任务队头任务'then2-2'，log 输出 "),v("strong",[t._v("then2-2")])]),t._v(" "),v("li",[t._v("微任务队列执行完毕，别忘了宏任务队列中的 setTimeout，log 输出 "),v("strong",[t._v("setTimeout")])])]),t._v(" "),v("p",[t._v("经过以上一番缜(xia)密(gao)分析，希望没有绕晕你，最后的输出结果就是：\nscript start -> promise1 -> script end -> then11 -> promise2 -> then2-1 -> then12 -> then2-2 -> setTimeout")]),t._v(" "),v("h4",{attrs:{id:"宏任务？微任务？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#宏任务？微任务？"}},[t._v("#")]),t._v(" 宏任务？微任务？")]),t._v(" "),v("p",[t._v("不知道大家看了宏任务和微任务之后会不会有一个疑惑，宏任务和微任务都是异步任务，微任务之前说过了是为了及时解决一些必要事件而产生的。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("为什么要有微任务？"),v("br"),t._v("\n为什么要有微任务的原因前面已经说了，这里就不再赘述，简单说一下就是为了及时处理一些任务，不然等到最后再执行的时候拿到的数据可能已经是被污染的数据达不到预期目标了。")])]),t._v(" "),v("li",[v("p",[t._v("什么是宏任务？什么是微任务？"),v("br"),t._v("\n相信大家在学习 Event Loop 查找资料的时候，肯定各种资料里面都会讲到宏任务和微任务，但是不知道你有没有灵魂拷问过你自己：什么是宏任务？什么是微任务？怎么区分宏任务和微任务？不能只是默许接受这个概念，在这里，我根据我的个人理解进行一番说(hu)明(che)")])]),t._v(" "),v("li",[v("p",[t._v("宏任务和微任务的真面目"),v("br"),t._v("\n其实在 Chrome 的源码中并没有什么宏任务和微任务的代码或是说明，在 JS 大会上提到过微任务这个名词，但是也没有说到底什么是微任务。")])])]),t._v(" "),v("p",[t._v("宏任务"),v("br"),t._v("\n文章最开始的时候说过，在 chrome 里，每个页面都对应一个进程。而该进程又有多个线程，比如 JS 线程、渲染线程、IO 线程、网络线程、定时器线程等等，这些线程之间的通信是通过向对象的任务队列中添加一个任务（postTask）来实现的。宏任务的本质可以认为是多线程事件循环或消息循环，也就是线程间通信的一个消息队列。")]),t._v(" "),v("p",[t._v("微任务"),v("br"),t._v("\n微任务是在运行宏任务/同步任务的时候产生的，是属于当前任务的，所以它不需要浏览器的支持，内置在 JS 当中，不需要 API 支持，直接在 JS 的引擎中就被执行掉了。")]),t._v(" "),v("p",[t._v("就拿 setTimeout 举例来说，当遇到它的时候，浏览器就会对 Event Loop 说：嘿，我有一个任务交给你，Event Loop 就会说：好的，我会把它加到我的 todoList 中，之后我会执行它，它是需要调用 API 的。")]),t._v(" "),v("p",[v("strong",[t._v("宏任务的真面目是浏览器派发，与 JS 引擎无关的，参与了 Event Loop 调度的任务")])]),t._v(" "),v("h4",{attrs:{id:"特殊的点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特殊的点"}},[t._v("#")]),t._v(" 特殊的点")]),t._v(" "),v("ol",[v("li",[t._v("async 隐式返回 Promise 作为结果")]),t._v(" "),v("li",[t._v("执行完 await 之后直接跳出 async 函数，让出执行的所有权")]),t._v(" "),v("li",[t._v("当前任务的其他代码执行完之后再次获得执行权进行执行")]),t._v(" "),v("li",[t._v('立即 resolve 的 Promise 对象，是在本轮"事件循环"的结束时执行，而不是在下一轮"事件循环"的开始时')])]),t._v(" "),v("h4",{attrs:{id:"再举个栗子"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#再举个栗子"}},[t._v("#")]),t._v(" 再举个栗子")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("  console.log('script start')\n\n  async function async1() {\n      await async2()\n      console.log('async1 end')\n  }\n  async function async2() {\n      console.log('async2 end')\n  }\n  async1()\n\n  setTimeout(function() {\n      console.log('setTimeout')\n  }, 0)\n\n  new Promise(resolve => {\n      console.log('Promise')\n      resolve()\n  })\n  .then(function() {\n      console.log('promise1')\n  })\n  .then(function() {\n      console.log('promise2')\n  })\n\n  console.log('script end')\n\n")])])]),v("p",[t._v("按照之前的分析方法去分析之后就会得出一个结果：\nscript start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout")]),t._v(" "),v("p",[t._v("可以看出 async1 函数获取执行权是作为微任务的队尾，但是，在 Chrome73(金丝雀) 版本之后，async 的执行优化了，它会在 promise1 和 promise2 的输出之前执行。笔者大概了解了一下应该是用 PromiseResolve 对 await 进行了优化，减少了 Promise 的再次创建，有兴趣的小伙伴可以看看 Chrome 的源码。")])])}),[],!1,null,null,null);e.default=a.exports}}]);